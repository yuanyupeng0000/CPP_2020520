/*
All modification made by Cambricon Corporation: Â© 2019 Cambricon Corporation
All rights reserved.
All other contributions:
Copyright (c) 2014--2019, the respective contributors
All rights reserved.
For the list of contributors go to https://github.com/BVLC/caffe/blob/master/CONTRIBUTORS.md
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Intel Corporation nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef EXAMPLES_YOLO_V2_TEST_PB_HPP_
#define EXAMPLES_YOLO_V2_TEST_PB_HPP_
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test.proto

#ifndef PROTOBUF_test_2eproto__INCLUDED
#define PROTOBUF_test_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h> // NOLINT

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_test_2eproto();
void protobuf_AssignDesc_test_2eproto();
void protobuf_ShutdownFile_test_2eproto();

class NormalizedBBox;

// ===================================================================

class NormalizedBBox : public ::google::protobuf::Message {
  public:
  NormalizedBBox();
  virtual ~NormalizedBBox();

  NormalizedBBox(const NormalizedBBox& from);

  inline NormalizedBBox& operator=(const NormalizedBBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NormalizedBBox& default_instance();

  void Swap(NormalizedBBox* other);

  // implements Message ----------------------------------------------

  NormalizedBBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NormalizedBBox& from);
  void MergeFrom(const NormalizedBBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;

  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float xmin = 1;
  inline bool has_xmin() const;
  inline void clear_xmin();
  static const int kXminFieldNumber = 1;
  inline float xmin() const;
  inline void set_xmin(float value);

  // optional float ymin = 2;
  inline bool has_ymin() const;
  inline void clear_ymin();
  static const int kYminFieldNumber = 2;
  inline float ymin() const;
  inline void set_ymin(float value);

  // optional float xmax = 3;
  inline bool has_xmax() const;
  inline void clear_xmax();
  static const int kXmaxFieldNumber = 3;
  inline float xmax() const;
  inline void set_xmax(float value);

  // optional float ymax = 4;
  inline bool has_ymax() const;
  inline void clear_ymax();
  static const int kYmaxFieldNumber = 4;
  inline float ymax() const;
  inline void set_ymax(float value);

  // optional int32 label = 5;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 5;
  inline ::google::protobuf::int32 label() const;
  inline void set_label(::google::protobuf::int32 value);

  // optional bool difficult = 6;
  inline bool has_difficult() const;
  inline void clear_difficult();
  static const int kDifficultFieldNumber = 6;
  inline bool difficult() const;
  inline void set_difficult(bool value);

  // optional float score = 7;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 7;
  inline float score() const;
  inline void set_score(float value);

  // optional float size = 8;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 8;
  inline float size() const;
  inline void set_size(float value);

  // @@protoc_insertion_point(class_scope:NormalizedBBox)
  private:
  inline void set_has_xmin();
  inline void clear_has_xmin();
  inline void set_has_ymin();
  inline void clear_has_ymin();
  inline void set_has_xmax();
  inline void clear_has_xmax();
  inline void set_has_ymax();
  inline void clear_has_ymax();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_difficult();
  inline void clear_has_difficult();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float xmin_;
  float ymin_;
  float xmax_;
  float ymax_;
  ::google::protobuf::int32 label_;
  bool difficult_;
  float score_;
  float size_;
  friend void protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static NormalizedBBox* default_instance_;
};
// ===================================================================

// ===================================================================

// NormalizedBBox

// optional float xmin = 1;
inline bool NormalizedBBox::has_xmin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NormalizedBBox::set_has_xmin() { _has_bits_[0] |= 0x00000001u; }
inline void NormalizedBBox::clear_has_xmin() { _has_bits_[0] &= ~0x00000001u; }
inline void NormalizedBBox::clear_xmin() {
  xmin_ = 0;
  clear_has_xmin();
}
inline float NormalizedBBox::xmin() const {
  // @@protoc_insertion_point(field_get:NormalizedBBox.xmin)
  return xmin_;
}
inline void NormalizedBBox::set_xmin(float value) {
  set_has_xmin();
  xmin_ = value;
  // @@protoc_insertion_point(field_set:NormalizedBBox.xmin)
}

// optional float ymin = 2;
inline bool NormalizedBBox::has_ymin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NormalizedBBox::set_has_ymin() { _has_bits_[0] |= 0x00000002u; }
inline void NormalizedBBox::clear_has_ymin() { _has_bits_[0] &= ~0x00000002u; }
inline void NormalizedBBox::clear_ymin() {
  ymin_ = 0;
  clear_has_ymin();
}
inline float NormalizedBBox::ymin() const {
  // @@protoc_insertion_point(field_get:NormalizedBBox.ymin)
  return ymin_;
}
inline void NormalizedBBox::set_ymin(float value) {
  set_has_ymin();
  ymin_ = value;
  // @@protoc_insertion_point(field_set:NormalizedBBox.ymin)
}

// optional float xmax = 3;
inline bool NormalizedBBox::has_xmax() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NormalizedBBox::set_has_xmax() { _has_bits_[0] |= 0x00000004u; }
inline void NormalizedBBox::clear_has_xmax() { _has_bits_[0] &= ~0x00000004u; }
inline void NormalizedBBox::clear_xmax() {
  xmax_ = 0;
  clear_has_xmax();
}
inline float NormalizedBBox::xmax() const {
  // @@protoc_insertion_point(field_get:NormalizedBBox.xmax)
  return xmax_;
}
inline void NormalizedBBox::set_xmax(float value) {
  set_has_xmax();
  xmax_ = value;
  // @@protoc_insertion_point(field_set:NormalizedBBox.xmax)
}

// optional float ymax = 4;
inline bool NormalizedBBox::has_ymax() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NormalizedBBox::set_has_ymax() { _has_bits_[0] |= 0x00000008u; }
inline void NormalizedBBox::clear_has_ymax() { _has_bits_[0] &= ~0x00000008u; }
inline void NormalizedBBox::clear_ymax() {
  ymax_ = 0;
  clear_has_ymax();
}
inline float NormalizedBBox::ymax() const {
  // @@protoc_insertion_point(field_get:NormalizedBBox.ymax)
  return ymax_;
}
inline void NormalizedBBox::set_ymax(float value) {
  set_has_ymax();
  ymax_ = value;
  // @@protoc_insertion_point(field_set:NormalizedBBox.ymax)
}

// optional int32 label = 5;
inline bool NormalizedBBox::has_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NormalizedBBox::set_has_label() { _has_bits_[0] |= 0x00000010u; }
inline void NormalizedBBox::clear_has_label() { _has_bits_[0] &= ~0x00000010u; }
inline void NormalizedBBox::clear_label() {
  label_ = 0;
  clear_has_label();
}
inline ::google::protobuf::int32 NormalizedBBox::label() const {
  // @@protoc_insertion_point(field_get:NormalizedBBox.label)
  return label_;
}
inline void NormalizedBBox::set_label(::google::protobuf::int32 value) {
  set_has_label();
  label_ = value;
  // @@protoc_insertion_point(field_set:NormalizedBBox.label)
}

// optional bool difficult = 6;
inline bool NormalizedBBox::has_difficult() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NormalizedBBox::set_has_difficult() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NormalizedBBox::clear_has_difficult() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NormalizedBBox::clear_difficult() {
  difficult_ = false;
  clear_has_difficult();
}
inline bool NormalizedBBox::difficult() const {
  // @@protoc_insertion_point(field_get:NormalizedBBox.difficult)
  return difficult_;
}
inline void NormalizedBBox::set_difficult(bool value) {
  set_has_difficult();
  difficult_ = value;
  // @@protoc_insertion_point(field_set:NormalizedBBox.difficult)
}

// optional float score = 7;
inline bool NormalizedBBox::has_score() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NormalizedBBox::set_has_score() { _has_bits_[0] |= 0x00000040u; }
inline void NormalizedBBox::clear_has_score() { _has_bits_[0] &= ~0x00000040u; }
inline void NormalizedBBox::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float NormalizedBBox::score() const {
  // @@protoc_insertion_point(field_get:NormalizedBBox.score)
  return score_;
}
inline void NormalizedBBox::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:NormalizedBBox.score)
}

// optional float size = 8;
inline bool NormalizedBBox::has_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NormalizedBBox::set_has_size() { _has_bits_[0] |= 0x00000080u; }
inline void NormalizedBBox::clear_has_size() { _has_bits_[0] &= ~0x00000080u; }
inline void NormalizedBBox::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline float NormalizedBBox::size() const {
  // @@protoc_insertion_point(field_get:NormalizedBBox.size)
  return size_;
}
inline void NormalizedBBox::set_size(float value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:NormalizedBBox.size)
}

// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {}  // namespace google
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_test_2eproto__INCLUDED

#include <algorithm>

#include <google/protobuf/descriptor.h> // NOLINT
#include <google/protobuf/generated_message_reflection.h> // NOLINT
#include <google/protobuf/io/coded_stream.h> // NOLINT
#include <google/protobuf/reflection_ops.h> // NOLINT
#include <google/protobuf/stubs/once.h> // NOLINT
#include <google/protobuf/wire_format.h> // NOLINT
#include <google/protobuf/wire_format_lite_inl.h> // NOLINT
// @@protoc_insertion_point(includes)

namespace { //NOLINT

const ::google::protobuf::Descriptor* NormalizedBBox_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
    NormalizedBBox_reflection_ = NULL;

}  // namespace

void protobuf_AssignDesc_test_2eproto() {
  protobuf_AddDesc_test_2eproto();
  const ::google::protobuf::FileDescriptor* file =
      ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
          "test.proto");
  GOOGLE_CHECK(file != NULL);
  NormalizedBBox_descriptor_ = file->message_type(0);
  static const int NormalizedBBox_offsets_[8] = {
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NormalizedBBox, xmin_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NormalizedBBox, ymin_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NormalizedBBox, xmax_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NormalizedBBox, ymax_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NormalizedBBox, label_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NormalizedBBox,
                                                     difficult_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NormalizedBBox, score_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NormalizedBBox, size_),
  };
  NormalizedBBox_reflection_ =
      new ::google::protobuf::internal::GeneratedMessageReflection(
          NormalizedBBox_descriptor_, NormalizedBBox::default_instance_,
          NormalizedBBox_offsets_,
          GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NormalizedBBox,
                                                         _has_bits_[0]),
          GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NormalizedBBox,
                                                         _unknown_fields_),
          -1, ::google::protobuf::DescriptorPool::generated_pool(),
          ::google::protobuf::MessageFactory::generated_factory(),
          sizeof(NormalizedBBox));
}

namespace { //NOLINT

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                                     &protobuf_AssignDesc_test_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NormalizedBBox_descriptor_, &NormalizedBBox::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_test_2eproto() {
  delete NormalizedBBox::default_instance_;
  delete NormalizedBBox_reflection_;
}

void protobuf_AddDesc_test_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      "\n\ntest.proto\"\207\001\n\016NormalizedBBox\022\014\n\004xmin\030"
      "\001 \001(\002\022\014\n\004ymin\030\002 "
      "\001(\002\022\014\n\004xmax\030\003 \001(\002\022\014\n\004yma"
      "x\030\004 \001(\002\022\r\n\005label\030\005 "
      "\001(\005\022\021\n\tdifficult\030\006 \001("
      "\010\022\r\n\005score\030\007 \001(\002\022\014\n\004size\030\010 "
      "\001(\002",
      150);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
      "test.proto", &protobuf_RegisterTypes);
  NormalizedBBox::default_instance_ = new NormalizedBBox();
  NormalizedBBox::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_test_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_test_2eproto {
  StaticDescriptorInitializer_test_2eproto() {
    protobuf_AddDesc_test_2eproto();
  }
} static_descriptor_initializer_test_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int NormalizedBBox::kXminFieldNumber;
const int NormalizedBBox::kYminFieldNumber;
const int NormalizedBBox::kXmaxFieldNumber;
const int NormalizedBBox::kYmaxFieldNumber;
const int NormalizedBBox::kLabelFieldNumber;
const int NormalizedBBox::kDifficultFieldNumber;
const int NormalizedBBox::kScoreFieldNumber;
const int NormalizedBBox::kSizeFieldNumber;
#endif  // !_MSC_VER

NormalizedBBox::NormalizedBBox() : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:NormalizedBBox)
}

void NormalizedBBox::InitAsDefaultInstance() {}

NormalizedBBox::NormalizedBBox(const NormalizedBBox& from)
    : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:NormalizedBBox)
}

void NormalizedBBox::SharedCtor() {
  _cached_size_ = 0;
  xmin_ = 0;
  ymin_ = 0;
  xmax_ = 0;
  ymax_ = 0;
  label_ = 0;
  difficult_ = false;
  score_ = 0;
  size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NormalizedBBox::~NormalizedBBox() {
  // @@protoc_insertion_point(destructor:NormalizedBBox)
  SharedDtor();
}

void NormalizedBBox::SharedDtor() {
}

void NormalizedBBox::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NormalizedBBox::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NormalizedBBox_descriptor_;
}

const NormalizedBBox& NormalizedBBox::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_test_2eproto();
  return *default_instance_;
}

NormalizedBBox* NormalizedBBox::default_instance_ = NULL;

NormalizedBBox* NormalizedBBox::New() const { return new NormalizedBBox; }

void NormalizedBBox::Clear() {
#define OFFSET_OF_FIELD_(f)                                             \
  (reinterpret_cast<char*>(&reinterpret_cast<NormalizedBBox*>(16)->f) - \ // NOLINT
    reinterpret_cast<char*>(16)

#define ZR_(first, last)                                  \
  do {                                                    \
    size_t f = OFFSET_OF_FIELD_(first);                   \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last); \
    ::memset(&first, 0, n);                               \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(xmin_, size_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NormalizedBBox::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) \
  if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:NormalizedBBox)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p =
        input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (
        ::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float xmin = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
               float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
              input, &xmin_)));
          set_has_xmin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_ymin;
        break;
      }

      // optional float ymin = 2;
      case 2: {
        if (tag == 21) {
        parse_ymin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
               float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
              input, &ymin_)));
          set_has_ymin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_xmax;
        break;
      }

      // optional float xmax = 3;
      case 3: {
        if (tag == 29) {
        parse_xmax:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
               float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
              input, &xmax_)));
          set_has_xmax();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_ymax;
        break;
      }

      // optional float ymax = 4;
      case 4: {
        if (tag == 37) {
        parse_ymax:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
               float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
              input, &ymax_)));
          set_has_ymax();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_label;
        break;
      }

      // optional int32 label = 5;
      case 5: {
        if (tag == 40) {
        parse_label:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
               ::google::protobuf::int32,
               ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
              input, &label_)));
          set_has_label();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_difficult;
        break;
      }

      // optional bool difficult = 6;
      case 6: {
        if (tag == 48) {
        parse_difficult:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
               bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
              input, &difficult_)));
          set_has_difficult();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_score;
        break;
      }

      // optional float score = 7;
      case 7: {
        if (tag == 61) {
        parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
               float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
              input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_size;
        break;
      }

      // optional float size = 8;
      case 8: {
        if (tag == 69) {
        parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
               float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
              input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
                ::google::protobuf::internal::WireFormatLite::
                    WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
            input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:NormalizedBBox)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:NormalizedBBox)
  return false;
#undef DO_
}

void NormalizedBBox::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:NormalizedBBox)
  // optional float xmin = 1;
  if (has_xmin()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->xmin(),
                                                             output);
  }

  // optional float ymin = 2;
  if (has_ymin()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->ymin(),
                                                             output);
  }

  // optional float xmax = 3;
  if (has_xmax()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->xmax(),
                                                             output);
  }

  // optional float ymax = 4;
  if (has_ymax()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->ymax(),
                                                             output);
  }

  // optional int32 label = 5;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->label(),
                                                             output);
  }

  // optional bool difficult = 6;
  if (has_difficult()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
        6, this->difficult(), output);
  }

  // optional float score = 7;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->score(),
                                                             output);
  }

  // optional float size = 8;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->size(),
                                                             output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:NormalizedBBox)
}

::google::protobuf::uint8* NormalizedBBox::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:NormalizedBBox)
  // optional float xmin = 1;
  if (has_xmin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(
        1, this->xmin(), target);
  }

  // optional float ymin = 2;
  if (has_ymin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(
        2, this->ymin(), target);
  }

  // optional float xmax = 3;
  if (has_xmax()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(
        3, this->xmax(), target);
  }

  // optional float ymax = 4;
  if (has_ymax()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(
        4, this->ymax(), target);
  }

  // optional int32 label = 5;
  if (has_label()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(
        5, this->label(), target);
  }

  // optional bool difficult = 6;
  if (has_difficult()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(
        6, this->difficult(), target);
  }

  // optional float score = 7;
  if (has_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(
        7, this->score(), target);
  }

  // optional float size = 8;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(
        8, this->size(), target);
  }

  if (!unknown_fields().empty()) {
    target =
        ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
            unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NormalizedBBox)
  return target;
}

int NormalizedBBox::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float xmin = 1;
    if (has_xmin()) {
      total_size += 1 + 4;
    }

    // optional float ymin = 2;
    if (has_ymin()) {
      total_size += 1 + 4;
    }

    // optional float xmax = 3;
    if (has_xmax()) {
      total_size += 1 + 4;
    }

    // optional float ymax = 4;
    if (has_ymax()) {
      total_size += 1 + 4;
    }

    // optional int32 label = 5;
    if (has_label()) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::Int32Size(
                            this->label());
    }

    // optional bool difficult = 6;
    if (has_difficult()) {
      total_size += 1 + 1;
    }

    // optional float score = 7;
    if (has_score()) {
      total_size += 1 + 4;
    }

    // optional float size = 8;
    if (has_size()) {
      total_size += 1 + 4;
    }
  }
  if (!unknown_fields().empty()) {
    total_size +=
        ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
            unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NormalizedBBox::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NormalizedBBox* source =
      ::google::protobuf::internal::dynamic_cast_if_available<
          const NormalizedBBox*>(&from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NormalizedBBox::MergeFrom(const NormalizedBBox& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_xmin()) {
      set_xmin(from.xmin());
    }
    if (from.has_ymin()) {
      set_ymin(from.ymin());
    }
    if (from.has_xmax()) {
      set_xmax(from.xmax());
    }
    if (from.has_ymax()) {
      set_ymax(from.ymax());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
    if (from.has_difficult()) {
      set_difficult(from.difficult());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NormalizedBBox::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NormalizedBBox::CopyFrom(const NormalizedBBox& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NormalizedBBox::IsInitialized() const { return true; }

void NormalizedBBox::Swap(NormalizedBBox* other) {
  if (other != this) {
    std::swap(xmin_, other->xmin_);
    std::swap(ymin_, other->ymin_);
    std::swap(xmax_, other->xmax_);
    std::swap(ymax_, other->ymax_);
    std::swap(label_, other->label_);
    std::swap(difficult_, other->difficult_);
    std::swap(score_, other->score_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NormalizedBBox::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NormalizedBBox_descriptor_;
  metadata.reflection = NormalizedBBox_reflection_;
  return metadata;
}

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // EXAMPLES_YOLO_V2_TEST_PB_HPP_
